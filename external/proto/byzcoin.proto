syntax = "proto2";
package byzcoin;
import "skipchain.proto";
import "onet.proto";
import "darc.proto";
import "trie.proto";

option java_package = "ch.epfl.dedis.lib.proto";
option java_outer_classname = "ByzCoinProto";

// DataHeader is the data passed to the Skipchain
message DataHeader {
  // TrieRoot is the root of the merkle tree of the colleciton after
  // applying the valid transactions.
  required bytes trieroot = 1;
  // ClientTransactionHash is the sha256 hash of all the transactions in the body
  required bytes clienttransactionhash = 2;
  // StateChangesHash is the sha256 of all the StateChanges generated by the
  // accepted transactions.
  required bytes statechangeshash = 3;
  // Timestamp is a Unix timestamp in nanoseconds.
  required sint64 timestamp = 4;
}

// DataBody is stored in the body of the skipblock, and it's hash is stored
// in the DataHeader.
message DataBody {
  repeated TxResult txresults = 1;
}

// ***
// These are the messages used in the API-calls
// ***

// CreateGenesisBlock asks the cisc-service to set up a new skipchain.
message CreateGenesisBlock {
  // Version of the protocol
  required sint32 version = 1;
  // Roster defines which nodes participate in the skipchain.
  required onet.Roster roster = 2;
  // GenesisDarc defines who is allowed to write to this skipchain.
  required darc.Darc genesisdarc = 3;
  // BlockInterval in int64.
  required sint64 blockinterval = 4;
  // Maximum block size. Zero (or not present in protobuf) means use the default, 4 megs.
  optional sint32 maxblocksize = 5;
}

// CreateGenesisBlockResponse holds the genesis-block of the new skipchain.
message CreateGenesisBlockResponse {
  // Version of the protocol
  required sint32 version = 1;
  // Skipblock of the created skipchain or empty if there was an error.
  optional skipchain.SkipBlock skipblock = 2;
}

// AddTxRequest requests to apply a new transaction to the ledger.
message AddTxRequest {
  // Version of the protocol
  required sint32 version = 1;
  // SkipchainID is the hash of the first skipblock
  required bytes skipchainid = 2;
  // Transaction to be applied to the kv-store
  required ClientTransaction transaction = 3;
  // How many block-intervals to wait for inclusion -
  // missing value or 0 means return immediately.
  optional sint32 inclusionwait = 4;
}

// AddTxResponse is the reply after an AddTxRequest is finished.
message AddTxResponse {
  // Version of the protocol
  required sint32 version = 1;
}

// GetProof returns the proof that the given key is in the trie.
message GetProof {
  // Version of the protocol
  required sint32 version = 1;
  // Key is the key we want to look up
  required bytes key = 2;
  // ID is any block that is known to us in the skipchain, can be the genesis
  // block or any later block. The proof returned will be starting at this block.
  required bytes id = 3;
}

// GetProofResponse can be used together with the Genesis block to proof that
// the returned key/value pair is in the trie.
message GetProofResponse {
  // Version of the protocol
  required sint32 version = 1;
  // Proof contains everything necessary to prove the inclusion
  // of the included key/value pair given a genesis skipblock.
  required Proof proof = 2;
}

// CheckAuthorization returns the list of actions that could be executed if the
// signatures of the given identities are present and valid
message CheckAuthorization {
  // Version of the protocol
  required sint32 version = 1;
  // ByzCoinID where to look up the darc
  required bytes byzcoinid = 2;
  // DarcID that holds the rules
  required bytes darcid = 3;
  // Identities that will sign together
  repeated darc.Identity identities = 4;
}

// CheckAuthorizationResponse returns a list of Actions that the given identities
// can execute in the given darc. The list can be empty, which means that the
// given identities have now authorization in that darc at all.
message CheckAuthorizationResponse {
  repeated string actions = 1;
}

// ChainConfig stores all the configuration information for one skipchain. It
// will be stored under the key "GenesisDarcID || OneNonce", in the trie. The
// GenesisDarcID is the value of GenesisReferenceID.
message ChainConfig {
  required sint64 blockinterval = 1;
  required onet.Roster roster = 2;
  required sint32 maxblocksize = 3;
}

// Proof represents everything necessary to verify a given
// key/value pair is stored in a skipchain. The proof is in three parts:
//   1. InclusionProof proofs the presence or absence of the key. In case of
//   the key being present, the value is included in the proof
//   2. Latest is used to verify the merkle tree root used in the proof is
//   stored in the latest skipblock
//   3. Links proves that the latest skipblock is part of the skipchain
//
// This Structure could later be moved to cothority/skipchain.
message Proof {
  // InclusionProof is the deserialized InclusionProof
  required trie.Proof inclusionproof = 1;
  // Providing the latest skipblock to retrieve the Merkle tree root.
  required skipchain.SkipBlock latest = 2;
  // Proving the path to the latest skipblock. The first ForwardLink has an
  // empty-sliced `From` and the genesis-block in `To`, together with the
  // roster of the genesis-block in the `NewRoster`.
  repeated skipchain.ForwardLink links = 3;
}

// Instruction holds only one of Spawn, Invoke, or Delete
message Instruction {
  // InstanceID is either the instance that can spawn a new instance, or the instance
  // that will be invoked or deleted.
  required bytes instanceid = 1;
  // Spawn creates a new instance.
  optional Spawn spawn = 2;
  // Invoke calls a method of an existing instance.
  optional Invoke invoke = 3;
  // Delete removes the given instance.
  optional Delete delete = 4;
  // SignerCounter must be set to a value that is one greater than what
  // was in the last instruction signed by the same signer. Every counter
  // must map to the corresponding element in Signature. The initial
  // counter is 1. Overflow is allowed.
  repeated uint64 signercounter = 5 [packed=true];
  // Signatures that are verified using the Darc controlling access to
  // the instance.
  repeated darc.Signature signatures = 6;
}

// Spawn is called upon an existing instance that will spawn a new instance.
message Spawn {
  // ContractID represents the kind of contract that needs to be spawn.
  required string contractid = 1;
  // Args holds all data necessary to spawn the new instance.
  repeated Argument args = 2;
}

// Invoke calls a method of an existing instance which will update its internal
// state.
message Invoke {
  // Command is interpreted by the contract.
  required string command = 1;
  // Args holds all data necessary for the successful execution of the command.
  repeated Argument args = 2;
}

// Delete removes the instance. The contract might enforce conditions that
// must be true before a Delete is executed.
message Delete {
}

// Argument is a name/value pair that will be passed to the contract.
message Argument {
  // Name can be any name recognized by the contract.
  required string name = 1;
  // Value must be binary marshalled
  required bytes value = 2;
}

// ClientTransaction is a slice of Instructions that will be applied in order.
// If any of the instructions fails, none of them will be applied.
// InstructionsHash must be the hash of the concatenation of all the
// instruction hashes (see the Hash method in Instruction), this hash is what
// every instruction must sign for the transaction to be valid.
message ClientTransaction {
  repeated Instruction instructions = 1;
}

// TxResult holds a transaction and the result of running it.
message TxResult {
  required ClientTransaction clienttransaction = 1;
  required bool accepted = 2;
}

// StateChange is one new state that will be applied to the collection.
message StateChange {
  // StateAction can be any of Create, Update, Remove
  required sint32 stateaction = 1;
  // InstanceID of the state to change
  required bytes instanceid = 2;
  // ContractID points to the contract that can interpret the value
  required bytes contractid = 3;
  // Value is the data needed by the contract
  required bytes value = 4;
  // DarcID is the Darc controlling access to this key.
  required bytes darcid = 5;
  // Version is the monotonically increased version of the instance
  required uint64 version = 6;
}

// Coin is a generic structure holding any type of coin. Coins are defined
// by a genesis coin instance that is unique for each type of coin.
message Coin {
  // Name points to the genesis instance of that coin.
  required bytes name = 1;
  // Value is the total number of coins of that type.
  required uint64 value = 2;
}

// StreamingRequest is a request asking the service to start streaming blocks
// on the chain specified by ID.
message StreamingRequest {
  required bytes id = 1;
}

// StreamingResponse is the reply (block) that is streamed back to the client
message StreamingResponse {
  optional skipchain.SkipBlock block = 1;
}

// DownloadState requests the current global state of that node.
// If it is the first call to the service, then Reset
// must be true, else an error will be returned, or old data
// might be used.
message DownloadState {
  // ByzCoinID of the state to download
  required bytes byzcoinid = 1;
  // Nonce is 0 for a new download, else it must be
  // equal to the nonce returned in DDownloadStateResponse.
  // In case Nonce is non-zero, but doesn't correspond
  // to the current session, an error is returned,
  // as only one download-session can be active at
  // any given moment.
  required uint64 nonce = 2;
  // Length of the statechanges to download
  required sint32 length = 3;
}

// DownloadStateResponse is returned by the service. If there are no
// Instances left, then the length of Instances is 0.
message DownloadStateResponse {
  // KeyValues holds a copy of a slice of DBKeyValues
  // directly from bboltdb
  repeated DBKeyValue keyvalues = 1;
  // Nonce to be used for the download. The Nonce
  // is generated by the server, and will be set
  // for every subsequent reply, too.
  required uint64 nonce = 2;
}

// DBKeyValue represents one element in bboltdb
message DBKeyValue {
  required bytes key = 1;
  required bytes value = 2;
}

// StateChangeBody represents the body part of a state change, which is the
// part that needs to be serialised and stored in a merkle tree.
message StateChangeBody {
  required sint32 stateaction = 1;
  required bytes contractid = 2;
  required bytes value = 3;
  required uint64 version = 4;
  required bytes darcid = 5;
}

// GetSignerCounters is a request to get the latest version for the specified
// identity.
message GetSignerCounters {
  repeated string signerids = 1;
  required bytes skipchainid = 2;
}

// GetSignerCountersResponse holds the latest version for the identity in the
// request.
message GetSignerCountersResponse {
  repeated uint64 counters = 1 [packed=true];
}

// GetInstanceVersion is a request asking the service to fetch
// the version of the given instance
message GetInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
  required uint64 version = 3;
}

// GetLastInstanceVersion is request asking for the last version
// of a given instance
message GetLastInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
}

// GetInstanceVersionResponse is the response for both
// GetInstanceVersion and GetLastInstanceVersion. It contains
// the state change if it exists and the block index where
// it has been applied
message GetInstanceVersionResponse {
  required StateChange statechange = 1;
  required sint32 blockindex = 2;
}

// GetAllInstanceVersion is a request asking for the list of
// state changes of a given instance
message GetAllInstanceVersion {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
}

// GetAllInstanceVersionResponse is the response that contains
// the list of state changes of a instance
message GetAllInstanceVersionResponse {
  repeated GetInstanceVersionResponse statechanges = 1;
}

// CheckStateChangeValidity is a request to get the list
// of state changes belonging to the same block as the
// targeted one to compute the hash
message CheckStateChangeValidity {
  required bytes skipchainid = 1;
  required bytes instanceid = 2;
  required uint64 version = 3;
}

// CheckStateChangeValidityResponse is the response with
// the list of state changes so that the hash can be
// compared against the one in the block
message CheckStateChangeValidityResponse {
  repeated StateChange statechanges = 1;
  required bytes blockid = 2;
}
